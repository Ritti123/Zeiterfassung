<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Zeiterfassung</title>
  <style>
    :root {
      --bg-color: #f4f6f8;
      --text-color: #333;
      --section-bg: #fff;
      --border-color: #ddd;
      --button-primary: #3498db;
      --button-danger: #e74c3c;
      --button-success: #2ecc71;
      --shadow: 0 1px 3px rgba(0,0,0,0.1);
      --input-border: #ccc;
      --stat-bg: #fff;
    }

    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --text-color: #f0f0f0;
      --section-bg: #2d2d2d;
      --border-color: #444;
      --button-primary: #2980b9;
      --button-danger: #c0392b;
      --button-success: #27ae60;
      --shadow: 0 1px 3px rgba(0,0,0,0.3);
      --input-border: #555;
      --stat-bg: #3d3d3d;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      max-width: 700px;
      margin: 0 auto;
      padding: 20px;
      background: var(--bg-color);
      color: var(--text-color);
      transition: all 0.3s ease;
    }
    h2, h3, h4 { margin-top: 0; }
    .section {
      background: var(--section-bg);
      border: 1px solid var(--border-color);
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 10px;
      box-shadow: var(--shadow);
    }
    input, select, button {
      padding: 10px;
      margin: 10px 0;
      width: 100%;
      box-sizing: border-box;
      border: 1px solid var(--input-border);
      border-radius: 6px;
      font-size: 16px;
      background: var(--section-bg);
      color: var(--text-color);
    }
    input::placeholder { color: #aaa; }
    button {
      background-color: var(--button-primary);
      color: white;
      border: none;
      cursor: pointer;
      font-weight: bold;
    }
    button.delete { background-color: var(--button-danger); }
    button.secondary { background-color: var(--button-success); }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      background-color: var(--section-bg);
    }
    th, td {
      border: 1px solid var(--border-color);
      padding: 8px;
      text-align: center;
    }
    th { background-color: var(--stat-bg); }
    .stats {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 20px;
    }
    .stat-box {
      flex: 1;
      min-width: 140px;
      border: 1px solid var(--border-color);
      padding: 10px;
      border-radius: 5px;
      background-color: var(--stat-bg);
    }
    .settings { margin-top: 20px; }
    .theme-toggle {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--button-primary);
      color: white;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }
    @media (max-width: 600px) {
      .stat-box { min-width: 100%; }
      table { font-size: 14px; }
      th, td { padding: 5px; }
    }
  </style>
</head>
<body>
  <button class="theme-toggle" id="theme-toggle">üåì</button>
  
  <div class="section">
    <h2>Zeiterfassung</h2>

    <div class="settings">
      <label for="work-hours">T√§gliche Sollstunden:</label>
      <input type="number" id="work-hours" min="1" max="24" value="8">

      <label for="vacation-days-year">Urlaubstage pro Jahr:</label>
      <input type="number" id="vacation-days-year" min="1" max="365" value="24">
    </div>

    <div>
      <label for="date">Datum:</label>
      <input type="date" id="date">
    </div>
    <div>
      <label for="start-time">Kommen:</label>
      <input type="time" id="start-time" placeholder="z.‚ÄØB. 08:00" pattern="[0-9]{2}:[0-9]{2}">
    </div>
    <div>
      <label for="end-time">Gehen:</label>
      <input type="time" id="end-time" placeholder="z.‚ÄØB. 16:30" pattern="[0-9]{2}:[0-9]{2}">
    </div>
    <div>
      <label for="break">Pause (Minuten):</label>
      <input type="number" id="break" value="30" placeholder="z.‚ÄØB. 30" min="0" max="240">
    </div>
    <div>
      <label for="type">Art:</label>
      <select id="type">
        <option value="Arbeit">Arbeit</option>
        <option value="Urlaub">Urlaub</option>
        <option value="Krank">Krank</option>
        <option value="Feiertag">Feiertag</option>
      </select>
    </div>
    <button id="add-entry-btn">Eintrag hinzuf√ºgen</button>

    <div id="time-range" style="display: none;">
      <label for="end-date">Bis Datum:</label>
      <input type="date" id="end-date">
      <button id="add-time-range-btn">Zeitraum hinzuf√ºgen</button>
    </div>

    <div>
      <label for="month">Monat anzeigen:</label>
      <input type="month" id="month">
    </div>

    <h3 id="report-title">Monatsreport</h3>
    <div style="overflow-x: auto;">
      <table id="time-entries">
        <thead>
          <tr>
            <th>Datum</th>
            <th>Kommen</th>
            <th>Gehen</th>
            <th>Pause</th>
            <th>Art</th>
            <th>Stunden</th>
            <th>Soll</th>
            <th>Differenz</th>
            <th>Aktion</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="stats">
      <div class="stat-box">
        <h4>√úberstunden</h4>
        <p id="overtime">0:00</p>
      </div>
      <div class="stat-box">
        <h4>Urlaubstage</h4>
        <p id="vacation-days">0 Tage (noch 24 verf√ºgbar)</p>
      </div>
      <div class="stat-box">
        <h4>Krankheitstage</h4>
        <p id="sick-days">0 Tage</p>
      </div>
    </div>

    <button id="export-csv-btn" class="secondary">CSV exportieren</button>
    <button id="export-pdf-btn" class="secondary">PDF exportieren</button>
    <button id="export-backup-btn" class="secondary">Backup speichern</button>
    <button id="import-backup-btn">Backup laden</button>
    <input type="file" id="import-file" style="display:none">
  </div>

  <script>
    // IndexedDB f√ºr bessere Performance
    const DB_NAME = 'TimeTrackingDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'timeEntries';
    let db;
    let timeEntries = [];
    let backupTimestamps = JSON.parse(localStorage.getItem('backupTimestamps') || '[]');

    // DOM-Elemente
    const addEntryBtn = document.getElementById('add-entry-btn');
    const exportCsvBtn = document.getElementById('export-csv-btn');
    const exportPdfBtn = document.getElementById('export-pdf-btn');
    const exportBackupBtn = document.getElementById('export-backup-btn');
    const importBackupBtn = document.getElementById('import-backup-btn');
    const importFile = document.getElementById('import-file');
    const tbody = document.querySelector('#time-entries tbody');
    const monthInput = document.getElementById('month');
    const reportTitle = document.getElementById('report-title');
    const themeToggle = document.getElementById('theme-toggle');
    const typeSelect = document.getElementById('type');
    const timeRangeDiv = document.getElementById('time-range');
    const addTimeRangeBtn = document.getElementById('add-time-range-btn');
    const workHoursInput = document.getElementById('work-hours');
    const vacationDaysInput = document.getElementById('vacation-days-year');

    // Initialisierung
    document.addEventListener('DOMContentLoaded', async () => {
      await initDB();
      const now = new Date();
      document.getElementById('date').valueAsDate = now;
      monthInput.value = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
      workHoursInput.value = localStorage.getItem('workHours') || 8;
      vacationDaysInput.value = localStorage.getItem('vacationDays') || 24;
      loadEntries();
      checkBackupReminder();
      
      // Theme aus localStorage laden
      const savedTheme = localStorage.getItem('theme') || 'light';
      document.documentElement.setAttribute('data-theme', savedTheme);
    });

    // Event Listener f√ºr Einstellungen
    workHoursInput.addEventListener('change', function() {
      localStorage.setItem('workHours', this.value);
      loadEntries();
    });

    vacationDaysInput.addEventListener('change', function() {
      localStorage.setItem('vacationDays', this.value);
      loadEntries();
    });

    // Event Listener
    addEntryBtn.addEventListener('click', addTimeEntry);
    exportCsvBtn.addEventListener('click', exportCSV);
    exportPdfBtn.addEventListener('click', exportPDF);
    exportBackupBtn.addEventListener('click', exportBackup);
    importBackupBtn.addEventListener('click', () => importFile.click());
    importFile.addEventListener('change', handleImport);
    monthInput.addEventListener('change', loadEntries);
    themeToggle.addEventListener('click', toggleTheme);
    typeSelect.addEventListener('change', (e) => {
      const showRange = ['Urlaub', 'Krank', 'Feiertag'].includes(e.target.value);
      timeRangeDiv.style.display = showRange ? 'block' : 'none';
    });
    addTimeRangeBtn.addEventListener('click', addTimeRange);

    // IndexedDB Initialisierung
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
          }
        };
        
        request.onsuccess = (event) => {
          db = event.target.result;
          resolve();
        };
        
        request.onerror = (event) => {
          console.error('IndexedDB error:', event.target.error);
          // Fallback zu localStorage
          timeEntries = JSON.parse(localStorage.getItem('timeEntries') || '[]');
          resolve();
        };
      });
    }

    // Daten in IndexedDB speichern
    function saveEntry(entry) {
      return new Promise((resolve, reject) => {
        if (!db) {
          // Fallback zu localStorage
          timeEntries.push(entry);
          localStorage.setItem('timeEntries', JSON.stringify(timeEntries));
          resolve();
          return;
        }
        
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.add(entry);
        
        request.onsuccess = () => resolve();
        request.onerror = (event) => {
          console.error('Error saving entry:', event.target.error);
          reject(event.target.error);
        };
      });
    }

    // Daten aus IndexedDB laden
    function loadEntries() {
      const selectedMonth = monthInput.value;
      const [year, month] = selectedMonth.split("-");
      const monthNames = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni', 
                         'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
      reportTitle.textContent = `Monatsreport ${monthNames[parseInt(month)-1]} ${year}`;

      if (!db) {
        // Fallback zu localStorage
        timeEntries = JSON.parse(localStorage.getItem('timeEntries') || '[]');
        renderEntries();
        return;
      }

      const transaction = db.transaction([STORE_NAME], 'readonly');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.getAll();

      request.onsuccess = (event) => {
        timeEntries = event.target.result || [];
        renderEntries();
      };

      request.onerror = (event) => {
        console.error('Error loading entries:', event.target.error);
        timeEntries = JSON.parse(localStorage.getItem('timeEntries') || '[]');
        renderEntries();
      };
    }

    // Eintr√§ge rendern
    function renderEntries() {
      tbody.innerHTML = '';
      let overtimeMinutes = 0;
      let vacation = 0;
      let sick = 0;
      let holiday = 0;

      const selectedMonth = monthInput.value;
      const entries = timeEntries
        .filter(e => e.date && e.date.startsWith(selectedMonth))
        .sort((a, b) => new Date(a.date) - new Date(b.date));
      
      const totalVacationDays = parseInt(localStorage.getItem('vacationDays') || 24);

      entries.forEach(entry => {
        const row = tbody.insertRow();
        row.insertCell(0).textContent = formatDate(entry.date);
        row.insertCell(1).textContent = entry.type === 'Arbeit' ? entry.start || '-' : '-';
        row.insertCell(2).textContent = entry.type === 'Arbeit' ? entry.end || '-' : '-';
        row.insertCell(3).textContent = entry.type === 'Arbeit' ? entry.pause || 0 : '-';
        row.insertCell(4).textContent = entry.type;
        row.insertCell(5).textContent = entry.hours || '0:00';

        let istMin = 0;
        if (entry.type === 'Arbeit') {
          const [h, m] = (entry.hours || '0:00').split(":").map(Number);
          istMin = h * 60 + m;
          const sollMin = entry.sollHours ? entry.sollHours * 60 : parseFloat(localStorage.getItem('workHours') || 8) * 60;
          overtimeMinutes += istMin - sollMin;
        } else if (entry.type === 'Urlaub') vacation++;
        else if (entry.type === 'Krank') sick++;
        else if (entry.type === 'Feiertag') holiday++;

        const sollHours = entry.sollHours ? entry.sollHours : parseFloat(localStorage.getItem('workHours') || 8);
        row.insertCell(6).textContent = entry.type === 'Arbeit' 
          ? `${Math.floor(sollHours)}:${String(Math.round((sollHours % 1) * 60)).padStart(2, '0')}`
          : '-';

        let diff = istMin - (sollHours * 60);
        row.insertCell(7).textContent = entry.type === 'Arbeit'
          ? `${diff < 0 ? '-' : ''}${Math.floor(Math.abs(diff) / 60)}:${String(Math.abs(diff) % 60).padStart(2, '0')}`
          : '-';

        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'L√∂schen';
        deleteBtn.className = 'delete';
        deleteBtn.onclick = () => deleteEntry(entry.id);
        row.insertCell(8).appendChild(deleteBtn);
      });

      // Statistik aktualisieren
      updateStats(overtimeMinutes, vacation, totalVacationDays, sick);
    }

    // Eintrag l√∂schen
    function deleteEntry(id) {
      if (!confirm("Eintrag wirklich l√∂schen?")) return;

      if (!db) {
        // Fallback zu localStorage
        timeEntries = timeEntries.filter(e => e.id !== id);
        localStorage.setItem('timeEntries', JSON.stringify(timeEntries));
        loadEntries();
        return;
      }

      const transaction = db.transaction([STORE_NAME], 'readwrite');
      const store = transaction.objectStore(STORE_NAME);
      const request = store.delete(id);

      request.onsuccess = () => {
        timeEntries = timeEntries.filter(e => e.id !== id);
        loadEntries();
      };

      request.onerror = (event) => {
        console.error('Error deleting entry:', event.target.error);
      };
    }

    // Eintrag hinzuf√ºgen
    async function addTimeEntry() {
      const date = document.getElementById('date').value;
      const start = document.getElementById('start-time').value;
      const end = document.getElementById('end-time').value;
      const pause = parseInt(document.getElementById('break').value) || 0;
      const type = document.getElementById('type').value;
      const sollHours = parseFloat(workHoursInput.value);

      if (!date) {
        alert('Bitte Datum ausf√ºllen.');
        return;
      }

      // Pr√ºfen auf doppelten Eintrag
      const existingEntry = timeEntries.find(e => e.date === date);
      if (existingEntry) {
        if (!confirm("F√ºr dieses Datum existiert bereits ein Eintrag. √úberschreiben?")) return;
        await deleteEntry(existingEntry.id);
      }

      // Validierung der Zeiten
      if (type === 'Arbeit') {
        if (!start || !end) {
          alert('Bitte Start- und Endzeit f√ºr Arbeitstage ausf√ºllen.');
          return;
        }

        if (!isValidTime(start) || !isValidTime(end)) {
          alert('Ung√ºltige Zeitangabe. Bitte im Format HH:MM eingeben (z.B. 08:30).');
          return;
        }

        const startDate = new Date(`${date}T${start}`);
        const endDate = new Date(`${date}T${end}`);
        const diff = (endDate - startDate) / 60000 - pause;
        
        if (diff <= 0) {
          alert('Endzeit muss nach Startzeit liegen.');
          return;
        }

        if (diff > 16 * 60) {
          if (!confirm(`Arbeitszeit von ${Math.floor(diff/60)} Stunden und ${Math.round(diff%60)} Minuten ist sehr lang. Trotzdem speichern?`)) {
            return;
          }
        }
      }

      if (pause < 0 || pause > 240) {
        alert('Pausenzeit muss zwischen 0 und 240 Minuten liegen.');
        return;
      }

      const entry = { 
        date, 
        type,
        hours: '0:00',
        pause: type === 'Arbeit' ? pause : 0,
        sollHours: sollHours
      };

      if (type === 'Arbeit') {
        const startDate = new Date(`${date}T${start}`);
        const endDate = new Date(`${date}T${end}`);
        const diff = (endDate - startDate) / 60000 - pause;
        const h = Math.floor(diff / 60);
        const m = Math.round(diff % 60);
        entry.hours = `${h}:${m.toString().padStart(2, '0')}`;
        entry.start = start;
        entry.end = end;
      }

      try {
        await saveEntry(entry);
        loadEntries();
        resetForm();
      } catch (error) {
        alert('Fehler beim Speichern: ' + error.message);
      }
    }

    // Zeitraum hinzuf√ºgen (f√ºr Urlaub/Krank/Feiertag)
    async function addTimeRange() {
      const startDate = document.getElementById('date').value;
      const endDate = document.getElementById('end-date').value;
      const type = document.getElementById('type').value;

      if (!startDate || !endDate) {
        alert('Bitte Start- und Enddatum ausf√ºllen.');
        return;
      }

      if (new Date(endDate) < new Date(startDate)) {
        alert('Enddatum muss nach Startdatum liegen.');
        return;
      }

      if (!confirm(`${type}-Zeitraum vom ${formatDate(startDate)} bis ${formatDate(endDate)} hinzuf√ºgen?`)) {
        return;
      }

      const currentDate = new Date(startDate);
      const end = new Date(endDate);

      // Pr√ºfen auf bestehende Eintr√§ge im Zeitraum
      const existingEntries = timeEntries.filter(e => {
        const entryDate = new Date(e.date);
        return entryDate >= currentDate && entryDate <= end;
      });

      if (existingEntries.length > 0) {
        if (!confirm(`${existingEntries.length} bestehende Eintr√§ge im Zeitraum werden √ºberschrieben. Fortfahren?`)) {
          return;
        }
        // L√∂sche bestehende Eintr√§ge
        for (const entry of existingEntries) {
          await deleteEntry(entry.id);
        }
      }

      while (currentDate <= end) {
        const dateStr = currentDate.toISOString().split('T')[0];
        const entry = { 
          date: dateStr, 
          type, 
          hours: '0:00',
          sollHours: parseFloat(workHoursInput.value)
        };

        try {
          await saveEntry(entry);
        } catch (error) {
          console.error('Error saving entry:', error);
        }

        currentDate.setDate(currentDate.getDate() + 1);
      }

      loadEntries();
      resetForm();
      timeRangeDiv.style.display = 'none';
    }

    // Formular zur√ºcksetzen
    function resetForm() {
      document.getElementById('start-time').value = '';
      document.getElementById('end-time').value = '';
      document.getElementById('break').value = '30';
      const nextDay = new Date(new Date(document.getElementById('date').value).getTime() + 86400000);
      document.getElementById('date').valueAsDate = new Date(nextDay);
      document.getElementById('end-date').value = '';
    }

    // Statistik aktualisieren
    function updateStats(overtimeMinutes, vacation, totalVacationDays, sick) {
      const oh = Math.floor(Math.abs(overtimeMinutes) / 60);
      const om = Math.abs(overtimeMinutes) % 60;
      const sign = overtimeMinutes < 0 ? "-" : "";
      document.getElementById('overtime').textContent = `${sign}${oh}:${String(om).padStart(2, '0')}`;
      
      const remainingVacation = totalVacationDays - vacation;
      document.getElementById('vacation-days').textContent = 
        `${vacation} Tage (noch ${remainingVacation} von ${totalVacationDays} verf√ºgbar)`;
      
      document.getElementById('sick-days').textContent = `${sick} Tage`;
    }

    // Theme umschalten
    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
    }

    // CSV Export
    function exportCSV() {
      const selectedMonth = monthInput.value;
      const [year, month] = selectedMonth.split("-");
      const monthNames = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni', 
                         'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
      const entries = timeEntries.filter(e => e.date && e.date.startsWith(selectedMonth));
      if (entries.length === 0) return alert('Keine Daten vorhanden.');

      let csv = `Monatsreport ${monthNames[parseInt(month)-1]} ${year}\nDatum;Kommen;Gehen;Pause;Art;Stunden;Sollstunden\n`;
      entries.forEach(e => {
        const sollHours = e.sollHours ? e.sollHours : parseFloat(localStorage.getItem('workHours') || 8);
        csv += `${formatDate(e.date)};${e.type === 'Arbeit' ? e.start || '' : ''};${e.type === 'Arbeit' ? e.end || '' : ''};${e.type === 'Arbeit' ? e.pause : ''};${e.type};${e.hours || '0:00'};${sollHours}\n`;
      });

      const overtime = document.getElementById('overtime').textContent;
      const vacation = document.getElementById('vacation-days').textContent;
      const sick = document.getElementById('sick-days').textContent;
      csv += `\n√úberstunden:;${overtime}\nUrlaubstage:;${vacation}\nKrankheitstage:;${sick}\n`;

      download(`Monatsreport_${monthNames[parseInt(month)-1]}_${year}.csv`, csv, 'text/csv');
    }

    // PDF Export (korrigierte Version)
    function exportPDF() {
      const selectedMonth = monthInput.value;
      const [year, month] = selectedMonth.split("-");
      const monthNames = ['Januar', 'Februar', 'M√§rz', 'April', 'Mai', 'Juni', 
                         'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
      const entries = timeEntries.filter(e => e.date && e.date.startsWith(selectedMonth));
      
      if (entries.length === 0) {
        alert('Keine Eintr√§ge f√ºr den ausgew√§hlten Monat vorhanden!');
        return;
      }

      try {
        // PDF erstellen (Querformat)
        const doc = new window.jspdf.jsPDF('landscape');
        
        // Titel
        doc.setFontSize(18);
        doc.text(`Monatsreport ${monthNames[parseInt(month)-1]} ${year}`, 140, 15, { align: 'center' });
        
        // Tabelle vorbereiten
        const headers = [['Datum', 'Kommen', 'Gehen', 'Pause', 'Art', 'Stunden', 'Soll', 'Differenz']];
        const data = entries.map(e => {
          const sollHours = e.sollHours ? e.sollHours : parseFloat(localStorage.getItem('workHours') || 8);
          const sollStr = `${Math.floor(sollHours)}:${String(Math.round((sollHours % 1) * 60)).padStart(2, '0')}`;
          
          let diffStr = '-';
          if (e.type === 'Arbeit') {
            const [h, m] = (e.hours || '0:00').split(":").map(Number);
            const istMin = h * 60 + m;
            const sollMin = sollHours * 60;
            const diff = istMin - sollMin;
            diffStr = `${diff < 0 ? '-' : ''}${Math.floor(Math.abs(diff) / 60)}:${String(Math.abs(diff) % 60).padStart(2, '0')}`;
          }
          
          return [
            formatDate(e.date),
            e.type === 'Arbeit' ? e.start || '-' : '-',
            e.type === 'Arbeit' ? e.end || '-' : '-',
            e.type === 'Arbeit' ? e.pause || '0' : '-',
            e.type,
            e.hours || '0:00',
            e.type === 'Arbeit' ? sollStr : '-',
            diffStr
          ];
        });

        // Tabelle einf√ºgen
        doc.autoTable({
          head: headers,
          body: data,
          startY: 25,
          margin: { horizontal: 10 },
          styles: { 
            fontSize: 9,
            cellPadding: 3,
            overflow: 'linebreak'
          },
          headStyles: { 
            fillColor: [52, 152, 219],
            textColor: 255
          }
        });

        // PDF speichern
        doc.save(`Monatsreport_${monthNames[parseInt(month)-1]}_${year}.pdf`);
        
      } catch (error) {
        console.error('PDF-Export fehlgeschlagen:', error);
        alert('Fehler beim PDF-Export: ' + error.message);
      }
    }

    // Backup exportieren
    function exportBackup() {
      const data = { 
        entries: timeEntries, 
        settings: {
          workHours: localStorage.getItem('workHours') || 8,
          vacationDays: localStorage.getItem('vacationDays') || 24
        },
        exported: new Date().toISOString() 
      };
      const now = new Date().getTime();
      backupTimestamps.push(now);
      while (backupTimestamps.length > 2) backupTimestamps.shift();
      localStorage.setItem('backupTimestamps', JSON.stringify(backupTimestamps));
      download(`backup_zeiterfassung_${now}.json`, JSON.stringify(data, null, 2), 'application/json');
    }

    // Backup importieren
    function handleImport(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = async function (event) {
        try {
          const data = JSON.parse(event.target.result);
          if (!Array.isArray(data.entries)) throw new Error('Ung√ºltiges Format');
          
          if (confirm(`${data.entries.length} Eintr√§ge importieren? Vorherige Daten werden √ºberschrieben.`)) {
            if (db) {
              // IndexedDB leeren
              const transaction = db.transaction([STORE_NAME], 'readwrite');
              const store = transaction.objectStore(STORE_NAME);
              const clearRequest = store.clear();
              
              clearRequest.onsuccess = async () => {
                // Neue Eintr√§ge hinzuf√ºgen
                for (const entry of data.entries) {
                  await saveEntry(entry);
                }
                
                // Einstellungen √ºbernehmen
                if (data.settings) {
                  localStorage.setItem('workHours', data.settings.workHours);
                  localStorage.setItem('vacationDays', data.settings.vacationDays);
                  document.getElementById('work-hours').value = data.settings.workHours;
                  document.getElementById('vacation-days-year').value = data.settings.vacationDays;
                }
                
                loadEntries();
                alert('Import erfolgreich.');
              };
            } else {
              // Fallback zu localStorage
              timeEntries = data.entries;
              localStorage.setItem('timeEntries', JSON.stringify(timeEntries));
              
              if (data.settings) {
                localStorage.setItem('workHours', data.settings.workHours);
                localStorage.setItem('vacationDays', data.settings.vacationDays);
                document.getElementById('work-hours').value = data.settings.workHours;
                document.getElementById('vacation-days-year').value = data.settings.vacationDays;
              }
              
              loadEntries();
              alert('Import erfolgreich.');
            }
          }
        } catch (err) {
          alert('Fehler beim Import: ' + err.message);
        }
      };
      reader.readAsText(file);
    }

    // Hilfsfunktionen
    function formatDate(dateStr) {
      const [y, m, d] = dateStr.split('-');
      return `${d}.${m}.${y}`;
    }

    function isValidTime(time) {
      return /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/.test(time);
    }

    function download(filename, content, type) {
      const blob = new Blob(["\uFEFF" + content], { type });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = filename;
      link.click();
      URL.revokeObjectURL(link.href);
    }

    function checkBackupReminder() {
      const last = backupTimestamps[backupTimestamps.length - 1] || 0;
      const now = new Date().getTime();
      const oneWeek = 7 * 24 * 60 * 60 * 1000;
      if (now - last > oneWeek) {
        alert("Es ist √ºber eine Woche seit dem letzten Backup vergangen. Bitte speichern Sie ein neues Backup.");
      }
    }
  </script>
  
  <!-- Korrigierte JS-Bibliotheken -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
  <script>
    // Korrekte Initialisierung f√ºr jsPDF
    window.jspdf = window.jspdf || {};
  </script>
</body>
</html>
